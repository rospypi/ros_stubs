import threading
from typing import (
    Any,
    BinaryIO,
    Callable,
    Dict,
    Generic,
    Iterator,
    List,
    Optional,
    Set,
    Tuple,
    Type,
    TypeVar,
    overload,
)

from genpy import Message as Message  # NOQA

_TMessage = TypeVar("_TMessage", bound=Message)
_TCallbackArgs = TypeVar("_TCallbackArgs")

python3: int

def isstring(s: Any) -> bool: ...

class Topic(Generic[_TMessage]):
    resolved_name: str = ...
    name: str = ...
    data_class: Type[_TMessage] = ...
    type: str = ...
    md5sum: str = ...
    reg_type: str = ...
    impl: "_TopicImpl[_TMessage]" = ...
    def __init__(
        self, name: str, data_class: Type[_TMessage], reg_type: str
    ) -> None: ...
    def get_num_connections(self) -> int: ...
    def unregister(self) -> None: ...

class Poller:
    poller: Any = ...
    add_fd: Callable[[int], None] = ...
    remove_fd: Callable[[int], None] = ...
    error_iter: Callable[[], Iterator[int]] = ...
    kevents: List[Any] = ...
    def __init__(self) -> None: ...
    def noop(self, *args: Any) -> None: ...
    def noop_iter(self) -> None: ...
    def add_poll(self, fd: int) -> None: ...
    def remove_poll(self, fd: int) -> None: ...
    def error_poll_iter(self) -> Iterator[int]: ...
    def add_epoll(self, fd: int) -> None: ...
    def remove_epoll(self, fd: int) -> None: ...
    def error_epoll_iter(self) -> Iterator[int]: ...
    def add_kqueue(self, fd: int) -> None: ...
    def error_kqueue_iter(self) -> Iterator[int]: ...
    def remove_kqueue(self, fd: int) -> None: ...

class _TopicImpl(Generic[_TMessage]):
    resolved_name: str = ...
    name: str = ...
    data_class: Type[_TMessage] = ...
    type: str = ...
    handler: Any = ...
    seq: int = ...
    c_lock: threading.RLock = ...
    connections: List[Any] = ...
    closed: bool = ...
    ref_count: int = ...
    connection_poll: Poller = ...
    def __init__(self, name: str, data_class: Type[_TMessage]) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def get_num_connections(self) -> int: ...
    def has_connection(self, endpoint_id: str) -> bool: ...
    def has_connections(self) -> bool: ...
    def add_connection(self, c: Any) -> bool: ...
    def check(self) -> None: ...
    def remove_connection(self, c: Any) -> None: ...
    def get_stats_info(self) -> List[Tuple[str, str, str, str, str, bool, str]]: ...
    def get_stats(self) -> Any: ...

class Subscriber(Topic[_TMessage]):
    callback: Callable[..., None] = ...
    callback_args: Any = ...
    @overload
    def __init__(
        self,
        name: str,
        data_class: Type[_TMessage],
        callback: Optional[Callable[[_TMessage, _TCallbackArgs], None]] = ...,
        callback_args: _TCallbackArgs = ...,
        queue_size: Optional[int] = ...,
        buff_size: int = ...,
        tcp_nodelay: bool = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        name: str,
        data_class: Type[_TMessage],
        callback: Optional[Callable[[_TMessage], None]] = ...,
        callback_args: None = ...,
        queue_size: Optional[int] = ...,
        buff_size: int = ...,
        tcp_nodelay: bool = ...,
    ) -> None: ...
    def unregister(self) -> None: ...

class _SubscriberImpl(_TopicImpl[_TMessage]):
    callbacks: List[Callable[..., None]] = ...
    queue_size: int = ...
    buff_size: int = ...
    tcp_nodelay: bool = ...
    statistics_logger: Any = ...
    def __init__(self, name: str, data_class: Type[_TMessage]) -> None: ...
    def close(self) -> None: ...
    def set_tcp_nodelay(self, tcp_nodelay: bool) -> None: ...
    def set_queue_size(self, queue_size: int) -> None: ...
    def set_buff_size(self, buff_size: int) -> None: ...
    def get_stats(self) -> Tuple[str, List[Tuple[str, int, int, int, bool]]]: ...
    @overload
    def add_callback(self, cb: Callable[[_TMessage], None], cb_args: None) -> None: ...
    @overload
    def add_callback(
        self, cb: Callable[[_TMessage, _TCallbackArgs], None], cb_args: _TCallbackArgs
    ) -> None: ...
    @overload
    def remove_callback(
        self, cb: Callable[[_TMessage], None], cb_args: None
    ) -> None: ...
    @overload
    def remove_callback(
        self, cb: Callable[[_TMessage, _TCallbackArgs], None], cb_args: _TCallbackArgs
    ) -> None: ...
    def receive_callback(self, msgs: _TMessage, connection: Any) -> None: ...

class SubscribeListener:
    def peer_subscribe(
        self,
        topic_name: str,
        topic_publish: Callable[[Message], None],
        peer_publish: Callable[[Message], None],
    ) -> None: ...
    def peer_unsubscribe(self, topic_name: str, num_peers: int) -> None: ...

class Publisher(Topic[_TMessage]):
    def __init__(
        self,
        name: str,
        data_class: Type[_TMessage],
        subscriber_listener: Optional[SubscribeListener] = ...,
        tcp_nodelay: bool = ...,
        latch: bool = ...,
        headers: Optional[Dict[str, Any]] = ...,
        queue_size: Optional[int] = ...,
    ) -> None: ...
    @overload
    def publish(self, instance: _TMessage) -> None: ...
    @overload
    def publish(self, *args: Any, **kwds: Any) -> None: ...

class _PublisherImpl(_TopicImpl[_TMessage]):
    buff: BinaryIO = ...
    publock: threading.RLock = ...
    subscriber_listeners: List[SubscribeListener] = ...
    headers: Dict[str, Any] = ...
    is_latch: bool = ...
    latch: Optional[_TMessage] = ...
    queue_size: int = ...
    message_data_sent: int = ...
    def __init__(self, name: str, data_class: Type[_TMessage]) -> None: ...
    def close(self) -> None: ...
    def add_headers(self, headers: Dict[str, Any]) -> None: ...
    def enable_latch(self) -> None: ...
    def set_queue_size(self, queue_size: int) -> None: ...
    def get_stats(self) -> Tuple[str, int, List[Tuple[str, int, int, bool]]]: ...
    def add_subscriber_listener(self, l: SubscribeListener) -> None: ...
    def acquire(self) -> None: ...
    def release(self) -> None: ...
    def add_connection(self, c: Any) -> bool: ...
    def remove_connection(self, c: Any) -> None: ...
    def publish(
        self, message: _TMessage, connection_override: Optional[Any] = ...
    ) -> bool: ...

class _TopicManager:
    pubs: Dict[str, _PublisherImpl[Message]] = ...
    subs: Dict[str, _SubscriberImpl[Message]] = ...
    topics: Set[str] = ...
    lock: threading.Condition = ...
    closed: bool = ...
    def __init__(self) -> None: ...
    def get_pub_sub_info(self) -> List[Any]: ...
    def get_pub_sub_stats(self) -> List[Any]: ...
    def close_all(self) -> None: ...
    def check_all(self) -> None: ...
    def get_impl(self, reg_type: str, resolved_name: str) -> _TopicImpl[Message]: ...
    def acquire_impl(
        self, reg_type: str, resolved_name: str, data_class: Type[_TMessage]
    ) -> _TopicImpl[_TMessage]: ...
    def release_impl(self, reg_type: str, resolved_name: str) -> None: ...
    def get_publisher_impl(self, resolved_name: str) -> _PublisherImpl[Message]: ...
    def get_subscriber_impl(self, resolved_name: str) -> _SubscriberImpl[Message]: ...
    def has_subscription(self, resolved_name: str) -> bool: ...
    def has_publication(self, resolved_name: str) -> bool: ...
    def get_topics(self) -> List[str]: ...
    def get_subscriptions(self) -> List[List[str]]: ...
    def get_publications(self) -> List[List[str]]: ...
