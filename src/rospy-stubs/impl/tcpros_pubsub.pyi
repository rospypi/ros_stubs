# WARNING: Automatically generated by stubgen
# Needs to be fixed manually

from typing import Any, Optional

import rospy.impl.transport
from rospy.core import logdebug as logdebug
from rospy.core import logerr as logerr
from rospy.core import logwarn as logwarn
from rospy.core import rospyerr as rospyerr
from rospy.impl.tcpros_base import DEFAULT_BUFF_SIZE as DEFAULT_BUFF_SIZE
from rospy.impl.tcpros_base import TCPROS as TCPROS
from rospy.impl.tcpros_base import TCPROSTransport as TCPROSTransport
from rospy.impl.tcpros_base import TCPROSTransportProtocol as TCPROSTransportProtocol
from rospy.impl.tcpros_base import (
    get_tcpros_server_address as get_tcpros_server_address,
)
from rospy.impl.tcpros_base import start_tcpros_server as start_tcpros_server

class TCPROSSub(TCPROSTransportProtocol):
    direction: Any = ...
    tcp_nodelay: Any = ...
    def __init__(
        self,
        resolved_name: Any,
        recv_data_class: Any,
        queue_size: Optional[Any] = ...,
        buff_size: Any = ...,
        tcp_nodelay: bool = ...,
    ) -> None: ...
    def get_header_fields(self): ...

class TCPROSPub(TCPROSTransportProtocol):
    pub_data_class: Any = ...
    direction: Any = ...
    is_latch: Any = ...
    headers: Any = ...
    def __init__(
        self,
        resolved_name: Any,
        pub_data_class: Any,
        is_latch: bool = ...,
        headers: Optional[Any] = ...,
    ) -> None: ...
    def get_header_fields(self): ...

def robust_connect_subscriber(
    conn: Any,
    dest_addr: Any,
    dest_port: Any,
    pub_uri: Any,
    receive_cb: Any,
    resolved_topic_name: Any,
) -> None: ...
def check_if_still_publisher(resolved_topic_name: Any, pub_uri: Any): ...

class TCPROSHandler(rospy.impl.transport.ProtocolHandler):
    tcp_nodelay_map: Any = ...
    def __init__(self) -> None: ...
    def set_tcp_nodelay(self, resolved_name: Any, tcp_nodelay: Any) -> None: ...
    def shutdown(self) -> None: ...
    def create_transport(
        self, resolved_name: Any, pub_uri: Any, protocol_params: Any
    ): ...
    def supports(self, protocol: Any): ...
    def get_supported(self): ...
    def init_publisher(self, resolved_name: Any, protocol: Any): ...
    def topic_connection_handler(self, sock: Any, client_addr: Any, header: Any): ...

class QueuedConnection:
    def __init__(self, connection: Any, queue_size: Any) -> None: ...
    def __getattr__(self, name: Any): ...
    def write_data(self, data: Any): ...
