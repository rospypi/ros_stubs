# WARNING: Automatically generated by stubgen
# Needs to be fixed manually

from typing import Any, Optional

from rospy.core import *
from rospy.core import logdebug as logdebug
from rospy.core import logerr as logerr
from rospy.core import loginfo as loginfo
from rospy.core import logwarn as logwarn
from rospy.core import rospydebug as rospydebug
from rospy.core import rospyerr as rospyerr
from rospy.core import rospywarn as rospywarn
from rospy.exceptions import ROSInternalException as ROSInternalException
from rospy.exceptions import TransportException as TransportException
from rospy.exceptions import TransportInitError as TransportInitError
from rospy.exceptions import TransportTerminated as TransportTerminated
from rospy.impl.transport import BIDIRECTIONAL as BIDIRECTIONAL
from rospy.impl.transport import Transport as Transport
from rospy.msg import deserialize_messages as deserialize_messages
from rospy.msg import serialize_message as serialize_message
from rospy.service import ServiceException as ServiceException

python3: int
logger: Any
DEFAULT_BUFF_SIZE: int
TCPROS: str

def recv_buff(sock: Any, b: Any, buff_size: Any): ...

class TCPServer:
    port: Any = ...
    addr: Any = ...
    is_shutdown: bool = ...
    inbound_handler: Any = ...
    server_sock: Any = ...
    def __init__(self, inbound_handler: Any, port: int = ...) -> None: ...
    def start(self) -> None: ...
    def run(self) -> None: ...
    def get_full_addr(self): ...
    def shutdown(self) -> None: ...

def init_tcpros_server(port: int = ...): ...
def start_tcpros_server(): ...
def get_tcpros_server_address(): ...

class TCPROSServer:
    port: Any = ...
    tcp_ros_server: Any = ...
    lock: Any = ...
    topic_connection_handler: Any = ...
    service_connection_handler: Any = ...
    def __init__(self, port: int = ...) -> None: ...
    def start_server(self): ...
    def get_address(self): ...
    def shutdown(self, reason: str = ...) -> None: ...

class TCPROSTransportProtocol:
    resolved_name: Any = ...
    recv_data_class: Any = ...
    queue_size: Any = ...
    buff_size: Any = ...
    direction: Any = ...
    def __init__(
        self,
        resolved_name: Any,
        recv_data_class: Any,
        queue_size: Optional[Any] = ...,
        buff_size: Any = ...,
    ) -> None: ...
    def read_messages(self, b: Any, msg_queue: Any, sock: Any) -> None: ...
    def get_header_fields(self): ...

class TCPROSTransport(Transport):
    transport_type: str = ...
    protocol: Any = ...
    socket: Any = ...
    endpoint_id: str = ...
    callerid_pub: str = ...
    dest_address: Any = ...
    read_buff: Any = ...
    write_buff: Any = ...
    header: Any = ...
    is_latched: bool = ...
    latch: Any = ...
    md5sum: Any = ...
    type: Any = ...
    local_endpoint: Any = ...
    remote_endpoint: Any = ...
    def __init__(
        self, protocol: Any, name: Any, header: Optional[Any] = ...
    ) -> None: ...
    def get_transport_info(self): ...
    def fileno(self): ...
    def set_endpoint_id(self, endpoint_id: Any) -> None: ...
    def set_socket(self, sock: Any, endpoint_id: Any) -> None: ...
    def connect(
        self,
        dest_addr: Any,
        dest_port: Any,
        endpoint_id: Any,
        timeout: Optional[Any] = ...,
    ) -> None: ...
    def write_header(self) -> None: ...
    def read_header(self) -> None: ...
    def send_message(self, msg: Any, seq: Any) -> None: ...
    def write_data(self, data: Any): ...
    def receive_once(self): ...
    def receive_loop(self, msgs_callback: Any) -> None: ...
    def close(self) -> None: ...
